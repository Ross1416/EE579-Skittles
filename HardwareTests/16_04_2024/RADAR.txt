#include <msp430.h> 
#include "LEDIndicator.h"

struct Ultrasonic{
    int distance;
    int time[2];
    char timeNumber;
    char trigPin;
    char echoPin;
    char port;
};

struct Ultrasonic ultraRADAR = {0, {0, 0}, 0, BIT0, BIT2, 1};
char read = 0;

int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer

    int i = 0;
    int arrayR[30] = {0};
    float arrayR_cm[30] = {0};

    //Trig pin
    P2DIR |= BIT0;	
    P2OUT &= ~BIT0;

    //Timer0 settings---------------------------------------------------RADAR-----------------------
    TA0CTL |= TASSEL_2;         // f = 1 MHz
    TA0CTL &= ~TAIFG;           //Clear interrupt
    TA0CTL &= ~TAIE;            //Disable interrupt on timer edge
    TA0CCTL0 &= ~(CCIFG+CCIE);
    TA0CCTL1 &= ~(CCIFG+CCIE);
    TA0CCTL2 &= ~(CCIFG+CCIE);
    TA0CCR0 = 27000;
    TA0CTL |= MC_1;             //Count to TA1CCR0

    //Capture compare 1 for timer 0 on input A (1.2)
    TA0CCTL1 |= CCIS_0 + CM_3 + CAP + CCIE + SCS;
    P1SEL |= BIT2;
    P1REN |= BIT2;
    P1OUT &= ~BIT2;
    TA0CCTL1 &= ~(CCIFG+SCCI+CCI);  //Clear interrupts

    setupLEDIndicator();

    read = 1;
    __bis_SR_register(GIE);

    while(1)
    {
        if(read == 1)
        {
            if (++i > 28)
            {
                i = 0;
            }
            arrayR[i] = ultraRADAR.distance;
            arrayR_cm[i] = ultraRADAR.distance/0.034/2;
            if(ultraRADAR.distance < 600)
            {
                LEDIndicatorOn();
            }
            else
            {
                LEDIndicatorOff();
            }
            read = 0;

            __delay_cycles(20000);

            P2OUT |= BIT0;  //Trigger sensor
            __delay_cycles(20);
            P2OUT &= ~BIT0; //Stop Trigger
        }
    }
}


#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer0_A1_ISR (void)
{
    switch(TA0IV)
    {
    case 0xA:   //OVERFLOW
        TA0CTL &= ~TAIFG;
        break;
    case TA0IV_TACCR1:  //TA1CCR1 (RADAR Ultrasonic)

        ultraRADAR.time[ultraRADAR.timeNumber] = TA0CCR1;
        ultraRADAR.timeNumber++;
        if (ultraRADAR.timeNumber==2)       //After up/down edges of feedback
        {
            ultraRADAR.distance = ultraRADAR.time[1]-ultraRADAR.time[0];
            if (ultraRADAR.distance < 0)    //When timer wrapped
            {
                ultraRADAR.distance += TA0CCR0;
            }
            read = 1;
            ultraRADAR.timeNumber=0;
        }
        TA0CCTL1 &= ~CCIFG;
        break;

    case TA0IV_TACCR2:  //TA1CCR2 (No interrupt as used in servo PWM)
        TA0CCTL2 &= ~CCIFG;
        break;
    }
}
