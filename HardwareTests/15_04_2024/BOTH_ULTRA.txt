#include <msp430.h> 

struct Ultrasonic{
    int distance;
    int time[2];
    char timeNumber;
    char trigPin;
    char echoPin;
    char port;
};
//#define dist2pulse(d)   ((1000000/100)*d*2/343)
//#define pulse2dist(p)   (50*p*343/1000000)
struct Ultrasonic ultraLeft = {0, {0, 0}, 0, BIT0, BIT2, 2};
struct Ultrasonic ultraRADAR = {0, {0, 0}, 0, BIT0, BIT2, 1};
char read = 0;

#pragma vector=TIMER1_A1_VECTOR
__interrupt void Timer1_A1_ISR (void)
{
    switch(TA1IV)
    {
    case 0xA:   //OVERFLOW
        TA1CTL &= ~TAIFG;
        break;
    case TA1IV_TACCR1:  //TA1CCR1 (Wall Ultrasonic)
        ultraLeft.time[ultraLeft.timeNumber] = TA1CCR1;
        ultraLeft.timeNumber++;
        if (ultraLeft.timeNumber==2)       //After up/down edges of feedback
        {
            ultraLeft.distance = ultraLeft.time[1]-ultraLeft.time[0];
            if (ultraLeft.distance < 0)    //When timer wrapped
            {
                ultraLeft.distance += TA1CCR0;
            }
            read = 1;
            ultraLeft.timeNumber=0;
        }
        TA1CCTL1 &= ~CCIFG;
        break;

    case TA1IV_TACCR2:  //TA1CCR2 (No interrupt as used in servo PWM)
         ultraLeft.time[ultraLeft.timeNumber] = TA1CCR2;
         ultraLeft.timeNumber++;
         if (ultraLeft.timeNumber==2)       //After up/down edges of feedback
         {
             ultraLeft.distance = ultraLeft.time[1]-ultraLeft.time[0];
             if (ultraLeft.distance < 0)    //When timer wrapped
             {
                 ultraLeft.distance += TA1CCR0;
             }
             read = 1;
             ultraLeft.timeNumber=0;
         }
         TA1CCTL2 &= ~CCIFG;
         break;
        break;
    }
}

#pragma vector=TIMER0_A0_VECTOR
__interrupt void TimerA0(void)
{
     ultraLeft.time[ultraLeft.timeNumber] = TA0CCR0;
     ultraLeft.timeNumber++;
     if (ultraLeft.timeNumber==2)       //After up/down edges of feedback
     {
         ultraLeft.distance = ultraLeft.time[1]-ultraLeft.time[0];
         if (ultraLeft.distance < 0)    //When timer wrapped
         {
             //ultraLeft.distance += TA0CCR0;
         }
         read = 1;
         ultraLeft.timeNumber=0;
     }
}

#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer0_A1_ISR (void)
{
    switch(TA0IV)
    {
    case 0xA:   //OVERFLOW
        TA0CTL &= ~TAIFG;
        break;
    case TA0IV_TACCR1:  //TA1CCR1 (RADAR Ultrasonic)

        ultraRADAR.time[ultraRADAR.timeNumber] = TA0CCR1;
        ultraRADAR.timeNumber++;
        if (ultraRADAR.timeNumber==2)       //After up/down edges of feedback
        {
            ultraRADAR.distance = ultraRADAR.time[1]-ultraRADAR.time[0];
            if (ultraRADAR.distance < 0)    //When timer wrapped
            {
                ultraRADAR.distance += TA0CCR0;
            }
            read = 1;
            ultraRADAR.timeNumber=0;
        }
        TA0CCTL1 &= ~CCIFG;
        break;

    case TA0IV_TACCR2:  //TA1CCR2 (No interrupt as used in servo PWM)
        TA0CCTL2 &= ~CCIFG;
        break;
    }
}

int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer

    int i = 0;
    int arrayL[30] = {0};
    int arrayR[30] = {0};
    float arrayL_cm[30] = {0};
    float arrayR_cm[30] = {0};

    //Trig pin
    P2DIR |= BIT0;
    P2OUT &= ~BIT0;

    //Timer1 settings---------------------------------------------------LEFT------------------------
    TA1CTL |= TASSEL_2;         // f = 1 MHz
    TA1CTL &= ~TAIFG;           //Clear interrupt
    TA1CTL &= ~TAIE;            //Disable interrupt on timer edge
    TA1CCTL0 &= ~(CCIFG+CCIE);
    TA1CCTL1 &= ~(CCIFG+CCIE);
    TA1CCTL2 &= ~(CCIFG+CCIE);
    TA1CCR0 = 27000;
    TA1CTL |= MC_1;             //Count to TA1CCR0

    //Timer0 settings---------------------------------------------------RADAR-----------------------
    TA0CTL |= TASSEL_2;         // f = 1 MHz
    TA0CTL &= ~TAIFG;           //Clear interrupt
    TA0CTL &= ~TAIE;            //Disable interrupt on timer edge
    TA0CCTL0 &= ~(CCIFG+CCIE);
    TA0CCTL1 &= ~(CCIFG+CCIE);
    TA0CCTL2 &= ~(CCIFG+CCIE);
    TA0CCR0 = 27000;
    TA0CTL |= MC_1;             //Count to TA1CCR0

    //Capture compare 1 for timer 0 on input A (1.2)
    TA0CCTL1 |= CCIS_0 + CM_3 + CAP + CCIE + SCS;
    P1SEL |= BIT2;
    P1REN |= BIT2;
    P1OUT &= ~BIT2;
    TA0CCTL1 &= ~(CCIFG+SCCI+CCI);  //Clear interrupts

    //Capture compare 1 for timer 1 on input B (2.2)
    TA1CCTL1 |= CCIS_1 + CM_3 + CAP + CCIE + SCS;
    P2SEL |= BIT2;
    P2REN |= BIT2;
    P2OUT &= ~BIT2;
    TA1CCTL1 &= ~(CCIFG+SCCI+CCI);  //Clear interrupts

    setupLEDIndicator();
    
    read = 1;
    __bis_SR_register(GIE);

    while(1)
    {
        if(read == 1)
        {
            if (++i > 28)
            {
                i = 0;
            }
            arrayL[i] = ultraLeft.distance;
            arrayR[i] = ultraRADAR.distance;
            arrayL_cm[i] = ultraLeft.distance*0.034/2;
            arrayR_cm[i] = ultraRADAR.distance/0.034/2;
            if(ultraRADAR.distance < 600)
            {
                LEDIndicatorOn();
            }
            else
            {
                LEDIndicatorOff();
            }
            read = 0;

            __delay_cycles(20000);

            P2OUT |= BIT0;  //Trigger sensor
            __delay_cycles(20);
            P2OUT &= ~BIT0; //Stop Trigger
        }
    }
}
